pipeline {
    agent any
    
    environment {
        // Variables d'environnement Ansible
        ANSIBLE_HOST_KEY_CHECKING = 'False'
        ANSIBLE_FORKS = '2'  // OptimisÃ© pour Raspberry Pi
        ANSIBLE_CONFIG = '/tmp/ansibleJenkins/ansible/ansible.cfg'
        ANSIBLE_INVENTORY_PATH = '/tmp/ansibleJenkins/ansible/inventory/hosts.ini'
        // Variables spÃ©cifiques pour le template post
        DEPLOYMENT_TYPE = 'DOCKER_INSTALLATION'
        OPERATION_TYPE = 'INSTALL'
    }
    
    parameters {
        // ParamÃ¨tre dynamique avec Active Choices Plugin
        // Alternative 1: Si vous avez Active Choices Plugin installÃ©
        /*
        activeChoice(
            choiceType: 'PT_SINGLE_SELECT',
            filterLength: 1,
            filterable: false,
            name: 'TARGET_SERVER',
            script: [
                $class: 'GroovyScript',
                script: [
                    classpath: [],
                    sandbox: false,
                    script: '''
                        def inventoryPath = "/tmp/ansibleJenkins/ansible/inventory/hosts.ini"
                        def file = new File(inventoryPath)
                        if (!file.exists()) {
                            return ["ERROR: Inventory file not found at ${inventoryPath}"]
                        }
                        
                        def groups = []
                        file.eachLine { line ->
                            line = line.trim()
                            if (line.startsWith('[') && line.endsWith(']')) {
                                def groupName = line[1..-2]
                                if (!groupName.contains(':children')) {
                                    groups.add(groupName)
                                }
                            }
                        }
                        return groups.sort()
                    '''
                ]
            ],
            description: 'Serveur cible pour l\'installation Docker (chargÃ© dynamiquement depuis l\'inventaire Ansible)'
        )
        */
        
        // Alternative 2: ParamÃ¨tre string pour saisie manuelle avec validation
        string(
            name: 'TARGET_SERVER',
            defaultValue: '',
            description: '''ðŸŽ¯ Nom du serveur cible (sera validÃ© contre l'inventaire Ansible):
            
            Serveurs disponibles dans votre inventaire:
            - ReverseProxy (192.168.1.2)
            - Windows (192.168.1.37) 
            - HomeAssistant (192.168.1.16)
            - RaspberryPi2 (127.0.0.1)
            - ServerVM1 (192.168.1.17)
            
            âš ï¸ Saisissez exactement le nom du groupe comme dans l'inventaire'''
        )
        
        choice(
            name: 'ANSIBLE_VERBOSITY',
            choices: [
                '0',
                '1',
                '2',
                '3',
                '4'
            ],
            description: '''ðŸ”§ Niveau de verbositÃ© Ansible:
            
            0 = Normal (dÃ©faut)
            1 = Verbose (-v)
            2 = Plus verbose (-vv)
            3 = Debug (-vvv)
            4 = Debug complet (-vvvv)'''
        )
    }
    
    stages {
        stage('Affichage inventaire dÃ©tectÃ©') {
            steps {
                script {
                    echo "ðŸ“‹ Inventaire Ansible dÃ©tectÃ© automatiquement:"
                    echo "Fichier: ${env.ANSIBLE_INVENTORY_PATH}"
                    
                    // Lire et afficher le contenu de l'inventaire
                    def inventoryContent = readFile("${env.ANSIBLE_INVENTORY_PATH}")
                    echo "Contenu de l'inventaire:"
                    echo inventoryContent
                    
                    // Parser et afficher les groupes disponibles
                    def availableGroups = getAnsibleGroups()
                    echo "Groupes disponibles dÃ©tectÃ©s: ${availableGroups.join(', ')}"
                    echo "Serveur sÃ©lectionnÃ©: ${params.TARGET_SERVER}"
                }
            }
        }
        
        stage('Validation des paramÃ¨tres') {
            steps {
                script {
                    echo "ðŸ” Validation des paramÃ¨tres d'installation Docker..."
                    echo "Serveur cible: ${params.TARGET_SERVER}"
                    echo "VerbositÃ© Ansible: ${params.ANSIBLE_VERBOSITY}"
                    
                    // VÃ©rifier que le groupe sÃ©lectionnÃ© existe dans l'inventaire
                    def availableGroups = getAnsibleGroups()
                    if (!availableGroups.contains(params.TARGET_SERVER)) {
                        error("Le serveur '${params.TARGET_SERVER}' n'existe pas dans l'inventaire Ansible!")
                    }
                    
                    // DÃ©terminer le flag de verbositÃ©
                    def verbosityFlag = ''
                    if (params.ANSIBLE_VERBOSITY != '0') {
                        verbosityFlag = '-' + 'v' * params.ANSIBLE_VERBOSITY.toInteger()
                    }
                    env.ANSIBLE_VERBOSE_FLAG = verbosityFlag
                    echo "Flag de verbositÃ©: '${env.ANSIBLE_VERBOSE_FLAG}'"
                    
                    // DÃ©terminer le type de serveur et l'adresse IP
                    def serverInfo = getServerInfo(params.TARGET_SERVER)
                    env.SERVER_TYPE = serverInfo.type
                    env.SERVER_IP = serverInfo.ip
                    
                    echo "Type de serveur dÃ©tectÃ©: ${env.SERVER_TYPE}"
                    echo "Adresse IP du serveur: ${env.SERVER_IP}"
                    
                    // DÃ©terminer le playbook selon le type de serveur
                    def selectedPlaybook = (env.SERVER_TYPE == 'Windows') ? 'install_docker_windows.yml' : 'install_docker_linux.yml'
                    env.SELECTED_PLAYBOOK = selectedPlaybook
                    echo "Playbook sÃ©lectionnÃ©: ${env.SELECTED_PLAYBOOK}"
                    
                    // Stocker les variables pour le post
                    env.DOCKER_INSTALLATION_TARGET = params.TARGET_SERVER
                }
            }
        }
        
        stage('VÃ©rification connectivitÃ© serveur') {
            steps {
                script {
                    echo "ðŸ”— Test de connectivitÃ© vers ${params.TARGET_SERVER} (${env.SERVER_IP})..."
                    
                    // Tester la connectivitÃ© avec Ansible
                    def isLinux = env.SELECTED_PLAYBOOK.contains('_linux.yml')
                    def isWindows = env.SELECTED_PLAYBOOK.contains('_windows.yml')

                    if (isLinux) {
                        withCredentials([
                            sshUserPrivateKey(credentialsId: 'ssh-key-ansible-user-secret-file', keyFileVariable: 'SSH_KEY_FILE', usernameVariable: 'SSH_USER')
                        ]) {
                            sh """
                                echo "Test de connectivitÃ© SSH vers ${env.SERVER_IP}..."
                                ansible ${params.TARGET_SERVER} -i ${env.ANSIBLE_INVENTORY_PATH} \
                                    -e ansible_ssh_private_key_file="\${SSH_KEY_FILE}" \
                                    -m ping ${env.ANSIBLE_VERBOSE_FLAG}
                            """
                        }
                    }
                    
                    if (isWindows) {
                        withCredentials([
                            usernamePassword(credentialsId: 'credentials-id-windows-user-password', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')
                        ]) {
                            sh """
                                echo "Test de connectivitÃ© WinRM vers ${env.SERVER_IP}..."
                                ansible ${params.TARGET_SERVER} -i ${env.ANSIBLE_INVENTORY_PATH} \
                                    -e ansible_user="\${USERNAME}" \
                                    -e ansible_password="\${PASSWORD}" \
                                    -m win_ping ${env.ANSIBLE_VERBOSE_FLAG}
                            """
                        }
                    }
                    
                    echo "âœ… ConnectivitÃ© OK vers ${params.TARGET_SERVER}"
                }
            }
        }
        
        stage('VÃ©rification Ansible') {
            steps {
                script {
                    // VÃ©rifier qu'Ansible est installÃ©
                    sh 'ansible --version'
                    
                    // VÃ©rifier que le playbook existe
                    sh """
                        if [ ! -f "/tmp/ansibleJenkins/ansible/playbook/${env.SELECTED_PLAYBOOK}" ]; then
                            echo "âŒ Playbook ${env.SELECTED_PLAYBOOK} non trouvÃ©!"
                            echo "Contenu du rÃ©pertoire playbook:"
                            ls -la /tmp/ansibleJenkins/ansible/playbook/ || echo "RÃ©pertoire non trouvÃ©"
                            exit 1
                        fi
                        
                        echo "âœ… Playbook ${env.SELECTED_PLAYBOOK} trouvÃ©"
                    """
                    
                    // VÃ©rifier la syntaxe du playbook
                    sh "ansible-playbook --syntax-check -i ${env.ANSIBLE_INVENTORY_PATH} /tmp/ansibleJenkins/ansible/playbook/${SELECTED_PLAYBOOK} -e HOST=${TARGET_SERVER}"
                }
            }
        }
        
        stage('Installation Docker') {
            steps {
                script {
                    def isLinux = env.SELECTED_PLAYBOOK.contains('_linux.yml')
                    def isWindows = env.SELECTED_PLAYBOOK.contains('_windows.yml')

                    if (isLinux) {
                        withCredentials([
                            sshUserPrivateKey(credentialsId: 'ssh-key-ansible-user-secret-file', keyFileVariable: 'SSH_KEY_FILE', usernameVariable: 'SSH_USER')
                        ]) {
                            echo "ðŸ³ DÃ©marrage de l'installation Docker sur Linux..."
                            echo "Serveur: ${params.TARGET_SERVER} (${env.SERVER_IP}) - ${env.SERVER_TYPE}"
                            echo "Playbook: ${env.SELECTED_PLAYBOOK}"
                            echo "VerbositÃ©: ${params.ANSIBLE_VERBOSITY} ${env.ANSIBLE_VERBOSE_FLAG}"
                            
                            sh '''
                                echo "ExÃ©cution du playbook d'installation Docker..."
                                echo "Aucune variable spÃ©cifique - Installation standard"
                                echo "Flag de verbositÃ©: ${ANSIBLE_VERBOSE_FLAG}"
                                
                                # Commande Ansible simple pour installation Docker
                                ansible-playbook -i ${ANSIBLE_INVENTORY_PATH} \
                                    /tmp/ansibleJenkins/ansible/playbook/${SELECTED_PLAYBOOK} \
                                    -e HOST=${TARGET_SERVER} \
                                    -e ansible_ssh_private_key_file="${SSH_KEY_FILE}" \
                                    ${ANSIBLE_VERBOSE_FLAG}
                            '''
                        }
                    }
                    
                    if (isWindows) {
                        withCredentials([
                            usernamePassword(credentialsId: 'credentials-id-windows-user-password', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')
                        ]) {
                            echo "ðŸ³ DÃ©marrage de l'installation Docker sur Windows..."
                            echo "Serveur: ${params.TARGET_SERVER} (${env.SERVER_IP}) - ${env.SERVER_TYPE}"
                            echo "Playbook: ${env.SELECTED_PLAYBOOK}"
                            echo "VerbositÃ©: ${params.ANSIBLE_VERBOSITY} ${env.ANSIBLE_VERBOSE_FLAG}"
                            
                            sh '''
                                echo "ExÃ©cution du playbook d'installation Docker..."
                                echo "Aucune variable spÃ©cifique - Installation standard"
                                echo "Flag de verbositÃ©: ${ANSIBLE_VERBOSE_FLAG}"
                                
                                # Commande Ansible simple pour installation Docker
                                ansible-playbook -i ${ANSIBLE_INVENTORY_PATH} \
                                    /tmp/ansibleJenkins/ansible/playbook/${SELECTED_PLAYBOOK} \
                                    -e HOST=${TARGET_SERVER} \
                                    -e ansible_user="${USERNAME}" \
                                    -e ansible_password="${PASSWORD}" \
                                    ${ANSIBLE_VERBOSE_FLAG}
                            '''
                        }
                    }
                }
            }
        }
    }
    
    post {
        always {
            echo "Installation Docker terminÃ©e"
            
            // CrÃ©er un rapport dÃ©taillÃ© avec informations dynamiques
            script {
                def report = """
                === RAPPORT INSTALLATION DOCKER (INVENTAIRE DYNAMIQUE) ===
                Serveur Cible: ${params.TARGET_SERVER}
                Adresse IP: ${env.SERVER_IP ?: 'Non dÃ©tectÃ©e'}
                Type Serveur: ${env.SERVER_TYPE ?: 'Non dÃ©fini'}
                Playbook: ${env.SELECTED_PLAYBOOK ?: 'Non dÃ©fini'}
                Inventaire: ${env.ANSIBLE_INVENTORY_PATH}
                Build: #${env.BUILD_NUMBER}
                Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}
                Statut: ${currentBuild.currentResult}
                DurÃ©e: ${currentBuild.durationString ?: 'N/A'}
                
                Groupes disponibles dans l'inventaire:
                ${getAnsibleGroups().join(', ')}
                ==========================================================
                """
                writeFile file: 'docker_installation_report.txt', text: report
                archiveArtifacts artifacts: 'docker_installation_report.txt', allowEmptyArchive: true
            }
        }
        success {
            script {
                echo "Installation Docker sur '${params.TARGET_SERVER}' (${env.SERVER_IP}) rÃ©ussie!"
                
                currentBuild.description = "Docker installÃ© â†’ ${params.TARGET_SERVER} (${env.SERVER_IP})"
                
                // Email de succÃ¨s avec informations dynamiques
                def emailBody = """
                    ðŸ³ INSTALLATION DOCKER - SUCCÃˆS

                    Serveur: ${params.TARGET_SERVER}
                    Adresse IP: ${env.SERVER_IP ?: 'Non dÃ©tectÃ©e'}
                    Type Serveur: ${env.SERVER_TYPE ?: 'Non dÃ©fini'}
                    Playbook: ${env.SELECTED_PLAYBOOK ?: 'Non dÃ©fini'}
                    Build: #${env.BUILD_NUMBER}
                    Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}
                    DurÃ©e: ${currentBuild.durationString ?: 'N/A'}

                    ðŸ“Š DÃ©tails du build: ${env.BUILD_URL}

                    Configuration dÃ©tectÃ©e automatiquement:
                    - Inventaire: ${env.ANSIBLE_INVENTORY_PATH}
                    - Groupes disponibles: ${getAnsibleGroups().join(', ')}
                    - ConnectivitÃ©: TestÃ©e avec succÃ¨s

                    âœ… L'installation Docker s'est terminÃ©e avec succÃ¨s.
                    
                    Prochaines Ã©tapes:
                    - Docker est maintenant installÃ© sur ${params.TARGET_SERVER} (${env.SERVER_IP})
                    - Vous pouvez tester avec: docker --version
                """
                
                mail to: 'l.kieran95@gmail.com',
                    subject: "[Jenkins] Installation Docker - ${params.TARGET_SERVER} - SuccÃ¨s",
                    body: emailBody
            }
        }
        failure {
            script {
                echo "Ã‰chec de l'installation Docker sur '${params.TARGET_SERVER}' (${env.SERVER_IP})"
                
                currentBuild.description = "Installation Docker â†’ Ã‰CHEC sur ${params.TARGET_SERVER} (${env.SERVER_IP})"
                
                // Email d'Ã©chec avec informations de diagnostic
                def emailBody = """
                    âŒ INSTALLATION DOCKER - Ã‰CHEC

                    Serveur: ${params.TARGET_SERVER}
                    Adresse IP: ${env.SERVER_IP ?: 'Non dÃ©tectÃ©e'}
                    Type Serveur: ${env.SERVER_TYPE ?: 'Non dÃ©fini'}
                    Playbook: ${env.SELECTED_PLAYBOOK ?: 'Non dÃ©fini'}
                    Build: #${env.BUILD_NUMBER}
                    Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}

                    ðŸ” Logs d'erreur: ${env.BUILD_URL}console

                    Diagnostic automatique:
                    - Inventaire: ${env.ANSIBLE_INVENTORY_PATH}
                    - Groupes dÃ©tectÃ©s: ${getAnsibleGroups().join(', ')}

                    âš ï¸ Veuillez vÃ©rifier les logs pour plus de dÃ©tails.
                    
                    Actions recommandÃ©es:
                    - VÃ©rifier la connectivitÃ© au serveur ${params.TARGET_SERVER} (${env.SERVER_IP})
                    - ContrÃ´ler les permissions d'installation
                    - Examiner les prÃ©requis systÃ¨me
                    - VÃ©rifier que l'inventaire Ansible est Ã  jour
                """
                
                mail to: 'l.kieran95@gmail.com',
                    subject: "[Jenkins] Installation Docker - Ã‰chec - ${params.TARGET_SERVER}",
                    body: emailBody
            }
        }
        cleanup {
            cleanWs()
        }
    }
}

// ===============================================
// FONCTIONS UTILITAIRES POUR INVENTAIRE DYNAMIQUE
// ===============================================

/**
 * Parse le fichier d'inventaire Ansible et retourne la liste des groupes
 * DOIT Ãªtre appelÃ© dans un contexte Jenkins (node/stage)
 */
def getAnsibleGroups() {
    def inventoryPath = '/tmp/ansibleJenkins/ansible/inventory/hosts.ini'
    
    // VÃ©rifier que le fichier existe
    if (!fileExists(inventoryPath)) {
        error("âŒ Fichier d'inventaire Ansible non trouvÃ© Ã : ${inventoryPath}")
    }
    
    def inventoryContent = readFile(inventoryPath)
    def groups = []
    
    // Parser le contenu ligne par ligne
    inventoryContent.split('\n').each { line ->
        line = line.trim()
        
        // DÃ©tecter les groupes [nom_groupe]
        if (line.startsWith('[') && line.endsWith(']')) {
            def groupName = line[1..-2] // Enlever les crochets
            
            // Exclure les mÃ©ta-groupes (avec :children)
            if (!groupName.contains(':children')) {
                groups.add(groupName)
            }
        }
    }
    
    // Trier alphabÃ©tiquement
    groups = groups.sort()
    
    echo "ðŸ“‹ Groupes dÃ©tectÃ©s dans l'inventaire: ${groups.join(', ')}"
    return groups
}

/**
 * Retourne les informations d'un serveur (type et IP) Ã  partir de l'inventaire
 * DOIT Ãªtre appelÃ© dans un contexte Jenkins (node/stage)
 */
def getServerInfo(String serverName) {
    def inventoryPath = '/tmp/ansibleJenkins/ansible/inventory/hosts.ini'
    
    if (!fileExists(inventoryPath)) {
        error("âŒ Fichier d'inventaire Ansible non trouvÃ© Ã : ${inventoryPath}")
    }
    
    def inventoryContent = readFile(inventoryPath)
    def currentGroup = ''
    def serverIp = 'Unknown'
    def serverType = 'Linux' // Par dÃ©faut
    
    // Parser le contenu pour trouver le serveur
    inventoryContent.split('\n').each { line ->
        line = line.trim()
        
        // DÃ©tecter les groupes
        if (line.startsWith('[') && line.endsWith(']')) {
            currentGroup = line[1..-2] // Enlever les crochets
            
            // DÃ©terminer le type selon le nom du groupe
            if (currentGroup.toLowerCase().contains('windows')) {
                serverType = 'Windows'
            } else {
                serverType = 'Linux'
            }
        }
        // Si on est dans le bon groupe et qu'on trouve une IP
        else if (currentGroup == serverName && line.contains('.')) {
            // Extraire l'IP (supposant format: IP ou hostname ansible_host=IP)
            if (line.contains('ansible_host=')) {
                serverIp = line.split('ansible_host=')[1].split(' ')[0]
            } else if (line ==~ /^\d+\.\d+\.\d+\.\d+.*/) {
                serverIp = line.split(' ')[0]
            }
        }
    }
    
    return [type: serverType, ip: serverIp]
}