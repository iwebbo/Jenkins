pipeline {
    agent any
    
    environment {
        ANSIBLE_HOST_KEY_CHECKING = 'False'
        ANSIBLE_FORKS = '2'
        ANSIBLE_CONFIG = '/tmp/ansibleJenkins/ansible/ansible.cfg'
        ANSIBLE_INVENTORY_PATH = '/tmp/ansibleJenkins/ansible/inventory/hosts.ini'
        DEPLOYMENT_TYPE = 'DOCKER_INSTALLATION'
        OPERATION_TYPE = 'INSTALL'
    }
    
    stages {
        stage('G√©n√©ration dynamique des param√®tres') {
            steps {
                script {
                    echo "üêç G√©n√©ration dynamique des serveurs avec Python..."
                    
                    // Cr√©er le script Python pour parser l'inventaire
                    writeFile file: 'parse_inventory.py', text: '''#!/usr/bin/env python3
import sys
import os
import json
import re
from pathlib import Path

def parse_ansible_inventory(inventory_path):
    """
    Parse un fichier d'inventaire Ansible et retourne les groupes et leurs informations
    """
    if not os.path.exists(inventory_path):
        return {
            "error": f"Fichier inventaire non trouv√©: {inventory_path}",
            "groups": [],
            "servers": {}
        }
    
    groups = []
    servers = {}
    current_group = None
    
    try:
        with open(inventory_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Ignorer les lignes vides et les commentaires
                if not line or line.startswith('#'):
                    continue
                
                # D√©tecter les groupes [nom_groupe]
                group_match = re.match(r'\\[([^\\]]+)\\]', line)
                if group_match:
                    group_name = group_match.group(1)
                    
                    # Exclure les m√©ta-groupes (avec :children, :vars)
                    if ':' not in group_name:
                        groups.append(group_name)
                        servers[group_name] = {
                            "type": "Windows" if "windows" in group_name.lower() else "Linux",
                            "hosts": [],
                            "line": line_num
                        }
                    current_group = group_name
                
                # Traiter les hosts dans un groupe
                elif current_group and ':' not in current_group:
                    # Formats support√©s:
                    # IP_ADDRESS
                    # hostname ansible_host=IP
                    # IP_ADDRESS ansible_user=user ansible_port=22
                    
                    host_info = {"raw_line": line}
                    
                    # Extraire l'IP ou hostname principal
                    parts = line.split()
                    if parts:
                        main_host = parts[0]
                        host_info["host"] = main_host
                        
                        # V√©rifier si c'est une IP directe
                        ip_pattern = r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'
                        if re.match(ip_pattern, main_host):
                            host_info["ip"] = main_host
                        else:
                            host_info["hostname"] = main_host
                    
                    # Extraire les variables Ansible (ansible_host, ansible_user, etc.)
                    for part in parts[1:]:
                        if '=' in part:
                            key, value = part.split('=', 1)
                            host_info[key] = value
                            if key == 'ansible_host':
                                host_info["ip"] = value
                    
                    # Ajouter l'host au groupe
                    if current_group in servers:
                        servers[current_group]["hosts"].append(host_info)
        
        # Trier les groupes alphab√©tiquement
        groups.sort()
        
        result = {
            "success": True,
            "groups": groups,
            "servers": servers,
            "total_groups": len(groups),
            "inventory_path": inventory_path
        }
        
        return result
        
    except Exception as e:
        return {
            "error": f"Erreur lors du parsing: {str(e)}",
            "groups": [],
            "servers": {},
            "inventory_path": inventory_path
        }

def get_server_info(servers_data, server_name):
    """
    R√©cup√®re les informations d√©taill√©es d'un serveur
    """
    if server_name in servers_data:
        server = servers_data[server_name]
        info = {
            "name": server_name,
            "type": server["type"],
            "hosts": server["hosts"],
            "ip": "Unknown"
        }
        
        # Trouver la premi√®re IP disponible
        for host in server["hosts"]:
            if "ip" in host:
                info["ip"] = host["ip"]
                break
            elif "host" in host and re.match(r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$', host["host"]):
                info["ip"] = host["host"]
                break
        
        return info
    
    return {"name": server_name, "type": "Unknown", "ip": "Unknown", "hosts": []}

def main():
    """
    Point d'entr√©e principal
    """
    if len(sys.argv) < 2:
        print("Usage: python3 parse_inventory.py <action> [server_name]")
        print("Actions disponibles:")
        print("  list_groups - Liste tous les groupes")
        print("  server_info <server_name> - Infos d'un serveur")
        print("  full_parse - Parse complet avec JSON")
        sys.exit(1)
    
    action = sys.argv[1]
    inventory_path = os.environ.get('ANSIBLE_INVENTORY_PATH', '/tmp/ansibleJenkins/ansible/inventory/hosts.ini')
    
    # Parser l'inventaire
    result = parse_ansible_inventory(inventory_path)
    
    if action == "list_groups":
        if "error" in result:
            print(f"ERROR: {result['error']}")
            sys.exit(1)
        
        for group in result["groups"]:
            print(group)
    
    elif action == "server_info":
        if len(sys.argv) < 3:
            print("ERROR: Nom du serveur requis pour server_info")
            sys.exit(1)
        
        server_name = sys.argv[2]
        if "error" in result:
            print(f"ERROR: {result['error']}")
            sys.exit(1)
        
        info = get_server_info(result["servers"], server_name)
        print(f"TYPE:{info['type']}")
        print(f"IP:{info['ip']}")
        print(f"NAME:{info['name']}")
    
    elif action == "full_parse":
        print(json.dumps(result, indent=2, ensure_ascii=False))
    
    else:
        print(f"ERROR: Action inconnue: {action}")
        sys.exit(1)

if __name__ == "__main__":
    main()
'''
                    
                    // Rendre le script ex√©cutable
                    sh 'chmod +x parse_inventory.py'
                    
                    // Tester la pr√©sence de Python
                    sh '''
                        echo "üîç V√©rification Python..."
                        if command -v python3 &> /dev/null; then
                            echo "‚úÖ Python3 disponible: $(python3 --version)"
                        elif command -v python &> /dev/null; then
                            echo "‚úÖ Python disponible: $(python --version)"
                        else
                            echo "‚ùå Python non trouv√©!"
                            exit 1
                        fi
                    '''
                    
                    // Parser l'inventaire avec Python et r√©cup√©rer les groupes
                    def pythonOutput = sh(
                        script: '''
                            export ANSIBLE_INVENTORY_PATH="${ANSIBLE_INVENTORY_PATH}"
                            if command -v python3 &> /dev/null; then
                                python3 parse_inventory.py list_groups
                            else
                                python parse_inventory.py list_groups
                            fi
                        ''',
                        returnStdout: true
                    ).trim()
                    
                    // V√©rifier les erreurs Python
                    if (pythonOutput.startsWith('ERROR:')) {
                        error("‚ùå ${pythonOutput}")
                    }
                    
                    // Convertir la sortie en liste
                    def availableServers = pythonOutput.split('\n').collect { it.trim() }.findAll { it != '' }
                    
                    echo "‚úÖ Serveurs d√©tect√©s avec Python:"
                    availableServers.each { server ->
                        echo "   üñ•Ô∏è ${server}"
                    }
                    
                    // Stocker les serveurs pour les √©tapes suivantes
                    env.AVAILABLE_SERVERS = availableServers.join(',')
                    env.PYTHON_PARSER_READY = 'true'
                    
                    // Afficher un r√©sum√© d√©taill√© avec le parser Python
                    echo "üìä Ex√©cution du parsing complet..."
                    def fullParseOutput = sh(
                        script: '''
                            export ANSIBLE_INVENTORY_PATH="${ANSIBLE_INVENTORY_PATH}"
                            if command -v python3 &> /dev/null; then
                                python3 parse_inventory.py full_parse
                            else
                                python parse_inventory.py full_parse
                            fi
                        ''',
                        returnStdout: true
                    )
                    
                    echo "üìã R√©sum√© de l'inventaire:"
                    echo fullParseOutput
                }
            }
        }
        
        stage('S√©lection interactive du serveur') {
            when {
                environment name: 'PYTHON_PARSER_READY', value: 'true'
            }
            steps {
                script {
                    def serverList = env.AVAILABLE_SERVERS.split(',').collect { it.trim() }
                    
                    echo "üéØ Interface de s√©lection du serveur..."
                    
                    // Interface de s√©lection interactive utilisant les serveurs d√©tect√©s par Python
                    def selectedServer = input(
                        id: 'ServerSelection',
                        message: """üêç Serveurs d√©tect√©s par Python depuis l'inventaire Ansible:

${env.ANSIBLE_INVENTORY_PATH}

S√©lectionnez le serveur cible pour l'installation Docker:""",
                        parameters: [
                            choice(
                                name: 'TARGET_SERVER',
                                choices: serverList,
                                description: """Serveurs charg√©s dynamiquement par script Python:
                                
üìä Total: ${serverList.size()} serveur(s) disponible(s)
üîÑ Mise √† jour automatique √† chaque build
‚úÖ Parsing robuste avec gestion d'erreurs Python"""
                            )
                        ]
                    )
                    
                    echo "üéØ Serveur s√©lectionn√©: ${selectedServer}"
                    env.TARGET_SERVER = selectedServer
                    
                    // Interface pour la verbosit√©
                    def verbosity = input(
                        id: 'VerbositySelection',
                        message: 'üîß Niveau de verbosit√© Ansible:',
                        parameters: [
                            choice(
                                name: 'VERBOSITY',
                                choices: ['0', '1', '2', '3', '4'],
                                description: """Debug Ansible:
0 = Normal (production)
1 = Verbose (-v) 
2 = Plus verbose (-vv)
3 = Debug (-vvv)
4 = Debug max (-vvvv)"""
                            )
                        ]
                    )
                    
                    env.ANSIBLE_VERBOSITY = verbosity
                    echo "üîß Verbosit√©: ${verbosity}"
                }
            }
        }
        
        stage('Analyse du serveur avec Python') {
            when {
                environment name: 'TARGET_SERVER', value: env.TARGET_SERVER
            }
            steps {
                script {
                    echo "üîç Analyse d√©taill√©e du serveur ${env.TARGET_SERVER} avec Python..."
                    
                    // Utiliser Python pour obtenir les informations d√©taill√©es du serveur
                    def serverInfoOutput = sh(
                        script: """
                            export ANSIBLE_INVENTORY_PATH="${ANSIBLE_INVENTORY_PATH}"
                            if command -v python3 &> /dev/null; then
                                python3 parse_inventory.py server_info "${env.TARGET_SERVER}"
                            else
                                python parse_inventory.py server_info "${env.TARGET_SERVER}"
                            fi
                        """,
                        returnStdout: true
                    ).trim()
                    
                    // Parser la sortie Python (format TYPE:Linux\\nIP:192.168.1.2\\nNAME:ReverseProxy)
                    def serverInfo = [:]
                    serverInfoOutput.split('\n').each { line ->
                        if (line.contains(':')) {
                            def parts = line.split(':', 2)
                            serverInfo[parts[0]] = parts[1]
                        }
                    }
                    
                    env.SERVER_TYPE = serverInfo['TYPE'] ?: 'Linux'
                    env.SERVER_IP = serverInfo['IP'] ?: 'Unknown'
                    env.SERVER_NAME = serverInfo['NAME'] ?: env.TARGET_SERVER
                    
                    echo "üìä Informations serveur (analys√©es par Python):"
                    echo "   üè∑Ô∏è Nom: ${env.SERVER_NAME}"
                    echo "   üìç IP: ${env.SERVER_IP}"
                    echo "   üíª Type: ${env.SERVER_TYPE}"
                    
                    // Configuration automatique bas√©e sur l'analyse Python
                    env.SELECTED_PLAYBOOK = (env.SERVER_TYPE == 'Windows') ? 
                        'install_docker_windows.yml' : 'install_docker_linux.yml'
                    
                    def verbosityFlag = env.ANSIBLE_VERBOSITY != '0' ? 
                        ('-' + 'v' * env.ANSIBLE_VERBOSITY.toInteger()) : ''
                    env.ANSIBLE_VERBOSE_FLAG = verbosityFlag
                    
                    echo "üìú Playbook: ${env.SELECTED_PLAYBOOK}"
                    echo "üîä Verbosit√©: '${env.ANSIBLE_VERBOSE_FLAG}'"
                }
            }
        }
        
        stage('Test connectivit√©') {
            steps {
                script {
                    echo "üîó Test connectivit√© vers ${env.TARGET_SERVER} (${env.SERVER_IP})..."
                    
                    def isLinux = !env.SERVER_TYPE.equals('Windows')
                    
                    if (isLinux) {
                        withCredentials([
                            sshUserPrivateKey(credentialsId: 'ssh-key-ansible-user-secret-file', 
                                            keyFileVariable: 'SSH_KEY_FILE', usernameVariable: 'SSH_USER')
                        ]) {
                            sh """
                                echo "üêß Test SSH vers ${env.SERVER_IP}..."
                                ansible ${env.TARGET_SERVER} -i ${env.ANSIBLE_INVENTORY_PATH} \
                                    -e ansible_ssh_private_key_file="\${SSH_KEY_FILE}" \
                                    -m ping \
                                    ${env.ANSIBLE_VERBOSE_FLAG}
                            """
                        }
                    } else {
                        withCredentials([
                            usernamePassword(credentialsId: 'credentials-id-windows-user-password', 
                                           usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')
                        ]) {
                            sh """
                                echo "ü™ü Test WinRM vers ${env.SERVER_IP}..."
                                ansible ${env.TARGET_SERVER} -i ${env.ANSIBLE_INVENTORY_PATH} \
                                    -e ansible_user="\${USERNAME}" \
                                    -e ansible_password="\${PASSWORD}" \
                                    -m win_ping \
                                    ${env.ANSIBLE_VERBOSE_FLAG}
                            """
                        }
                    }
                    
                    echo "‚úÖ Connectivit√© valid√©e !"
                }
            }
        }
        
        stage('Confirmation finale') {
            steps {
                script {
                    // R√©capitulatif final avec toutes les informations Python
                    def summary = """
üêç R√âCAPITULATIF - INSTALLATION DOCKER
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìä Serveur analys√© par Python:
   ‚Ä¢ Nom: ${env.SERVER_NAME}
   ‚Ä¢ Type: ${env.SERVER_TYPE}  
   ‚Ä¢ IP: ${env.SERVER_IP}

üîß Configuration:
   ‚Ä¢ Playbook: ${env.SELECTED_PLAYBOOK}
   ‚Ä¢ Verbosit√©: ${env.ANSIBLE_VERBOSITY} ${env.ANSIBLE_VERBOSE_FLAG}
   ‚Ä¢ Inventaire: ${env.ANSIBLE_INVENTORY_PATH}

‚úÖ Connectivit√©: Test√©e et valid√©e

Proc√©der √† l'installation Docker ?
                    """
                    
                    def proceed = input(
                        id: 'FinalConfirmation',
                        message: summary,
                        ok: 'üöÄ Installer Docker maintenant',
                        submitterParameter: 'INSTALLER_USER'
                    )
                    
                    env.INSTALLER_USER = proceed
                    echo "üë§ Installation approuv√©e par: ${env.INSTALLER_USER}"
                }
            }
        }
        
        stage('Installation Docker') {
            steps {
                script {
                    echo "üê≥ Installation Docker via Ansible..."
                    echo "üéØ Cible: ${env.TARGET_SERVER} (${env.SERVER_IP})"
                    echo "üë§ Lanc√©e par: ${env.INSTALLER_USER}"
                    
                    def isLinux = !env.SERVER_TYPE.equals('Windows')
                    
                    if (isLinux) {
                        withCredentials([
                            sshUserPrivateKey(credentialsId: 'ssh-key-ansible-user-secret-file', 
                                            keyFileVariable: 'SSH_KEY_FILE', usernameVariable: 'SSH_USER')
                        ]) {
                            sh '''
                                echo "üêß Installation Docker Engine (Linux)..."
                                ansible-playbook -i ${ANSIBLE_INVENTORY_PATH} \
                                    /tmp/ansibleJenkins/ansible/playbook/${SELECTED_PLAYBOOK} \
                                    -e HOST=${TARGET_SERVER} \
                                    -e ansible_ssh_private_key_file="${SSH_KEY_FILE}" \
                                    ${ANSIBLE_VERBOSE_FLAG}
                            '''
                        }
                    } else {
                        withCredentials([
                            usernamePassword(credentialsId: 'credentials-id-windows-user-password', 
                                           usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')
                        ]) {
                            sh '''
                                echo "ü™ü Installation Docker Desktop (Windows)..."
                                ansible-playbook -i ${ANSIBLE_INVENTORY_PATH} \
                                    /tmp/ansibleJenkins/ansible/playbook/${SELECTED_PLAYBOOK} \
                                    -e HOST=${TARGET_SERVER} \
                                    -e ansible_user="${USERNAME}" \
                                    -e ansible_password="${PASSWORD}" \
                                    ${ANSIBLE_VERBOSE_FLAG}
                            '''
                        }
                    }
                    
                    echo "‚úÖ Installation Docker termin√©e !"
                }
            }
        }
        
        stage('V√©rification Python post-installation') {
            steps {
                script {
                    echo "üîç V√©rification Docker avec Ansible..."
                    
                    def isLinux = !env.SERVER_TYPE.equals('Windows')
                    
                    if (isLinux) {
                        withCredentials([
                            sshUserPrivateKey(credentialsId: 'ssh-key-ansible-user-secret-file', 
                                            keyFileVariable: 'SSH_KEY_FILE', usernameVariable: 'SSH_USER')
                        ]) {
                            try {
                                def dockerVersion = sh(
                                    script: """
                                        ansible ${env.TARGET_SERVER} -i ${env.ANSIBLE_INVENTORY_PATH} \
                                            -e ansible_ssh_private_key_file="\${SSH_KEY_FILE}" \
                                            -m shell -a "docker --version" \
                                            --one-line
                                    """,
                                    returnStdout: true
                                ).trim()
                                
                                echo "‚úÖ Docker install√©: ${dockerVersion}"
                                env.DOCKER_VERSION = dockerVersion
                                
                            } catch (Exception e) {
                                echo "‚ö†Ô∏è Impossible de v√©rifier Docker (peut n√©cessiter un red√©marrage)"
                                env.DOCKER_VERSION = "Installation r√©ussie - V√©rification manuelle requise"
                            }
                        }
                    } else {
                        withCredentials([
                            usernamePassword(credentialsId: 'credentials-id-windows-user-password', 
                                           usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')
                        ]) {
                            try {
                                def dockerVersion = sh(
                                    script: """
                                        ansible ${env.TARGET_SERVER} -i ${env.ANSIBLE_INVENTORY_PATH} \
                                            -e ansible_user="\${USERNAME}" \
                                            -e ansible_password="\${PASSWORD}" \
                                            -m win_shell -a "docker --version" \
                                            --one-line
                                    """,
                                    returnStdout: true
                                ).trim()
                                
                                echo "‚úÖ Docker install√©: ${dockerVersion}"
                                env.DOCKER_VERSION = dockerVersion
                                
                            } catch (Exception e) {
                                echo "‚ö†Ô∏è Docker Desktop peut n√©cessiter un red√©marrage Windows"
                                env.DOCKER_VERSION = "Installation r√©ussie - Red√©marrage Windows recommand√©"
                            }
                        }
                    }
                }
            }
        }
    }
    
    post {
        success {
            script {
                currentBuild.description = "‚úÖ Docker ‚Üí ${env.TARGET_SERVER} (${env.SERVER_IP}) via Python"
                
                def emailBody = """
üê≥ INSTALLATION DOCKER - SUCC√àS 
üêç Powered by Python Parser

‚úÖ Installation r√©ussie !

üìä Serveur analys√© par Python:
‚Ä¢ Nom: ${env.SERVER_NAME}
‚Ä¢ Type: ${env.SERVER_TYPE}
‚Ä¢ IP: ${env.SERVER_IP}
‚Ä¢ Version Docker: ${env.DOCKER_VERSION ?: '√Ä v√©rifier manuellement'}

üîß Configuration:
‚Ä¢ Playbook: ${env.SELECTED_PLAYBOOK}
‚Ä¢ Verbosit√©: ${env.ANSIBLE_VERBOSITY}
‚Ä¢ Approuv√© par: ${env.INSTALLER_USER}

üìà D√©tection dynamique:
‚Ä¢ Parser Python: ‚úÖ Fonctionnel
‚Ä¢ Inventaire: ${env.ANSIBLE_INVENTORY_PATH}
‚Ä¢ Serveurs d√©tect√©s: ${env.AVAILABLE_SERVERS?.split(',')?.size()} au total

üîó Build: #${env.BUILD_NUMBER} - ${env.BUILD_URL}

Docker est pr√™t sur ${env.TARGET_SERVER} ! üöÄ
                """
                
                mail to: 'l.kieran95@gmail.com',
                    subject: "[Jenkins] ‚úÖ Docker install√© (Python) - ${env.TARGET_SERVER}",
                    body: emailBody
            }
        }
        failure {
            script {
                currentBuild.description = "‚ùå √âchec Docker Python - ${env.TARGET_SERVER ?: 'Serveur non d√©fini'}"
                
                mail to: 'l.kieran95@gmail.com',
                    subject: "[Jenkins] ‚ùå √âchec installation Docker (Python) - ${env.TARGET_SERVER ?: 'Serveur inconnu'}",
                    body: """
‚ùå INSTALLATION DOCKER - √âCHEC
üêç Python Parser utilis√©

üí• Erreur lors de l'installation

üìä Contexte:
‚Ä¢ Serveur: ${env.TARGET_SERVER ?: 'Non s√©lectionn√©'}
‚Ä¢ IP: ${env.SERVER_IP ?: 'Non d√©tect√©e'}
‚Ä¢ Type: ${env.SERVER_TYPE ?: 'Non d√©fini'}
‚Ä¢ Build: #${env.BUILD_NUMBER}

üîç Logs: ${env.BUILD_URL}console
                    """
            }
        }
        always {
            script {
                // Archiver le script Python pour debug
                archiveArtifacts artifacts: 'parse_inventory.py', allowEmptyArchive: true
                
                // Rapport d√©taill√©
                def report = """
=== RAPPORT INSTALLATION DOCKER (PYTHON PARSER) ===
Parser Python: ‚úÖ Utilis√©
Serveurs d√©tect√©s: ${env.AVAILABLE_SERVERS ?: 'Aucun'}
Serveur s√©lectionn√©: ${env.TARGET_SERVER ?: 'Non s√©lectionn√©'}
Nom serveur: ${env.SERVER_NAME ?: 'Non d√©fini'}
Type serveur: ${env.SERVER_TYPE ?: 'Non d√©fini'}
IP serveur: ${env.SERVER_IP ?: 'Non d√©finie'}
Playbook: ${env.SELECTED_PLAYBOOK ?: 'Non d√©fini'}
Verbosit√©: ${env.ANSIBLE_VERBOSITY ?: 'Non d√©finie'}
Installateur: ${env.INSTALLER_USER ?: 'Non d√©fini'}
Version Docker: ${env.DOCKER_VERSION ?: 'Non v√©rifi√©e'}
Inventaire: ${env.ANSIBLE_INVENTORY_PATH}
Build: #${env.BUILD_NUMBER}
Statut: ${currentBuild.currentResult}
Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}
Dur√©e: ${currentBuild.durationString ?: 'N/A'}
======================================================
                """
                
                writeFile file: 'docker_installation_python_report.txt', text: report
                archiveArtifacts artifacts: 'docker_installation_python_report.txt', allowEmptyArchive: true
            }
        }
        cleanup {
            // Garder les fichiers Python pour debug si n√©cessaire
            echo "üßπ Nettoyage (fichiers Python conserv√©s pour debug)"
        }
    }
}