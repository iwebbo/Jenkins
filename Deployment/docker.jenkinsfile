pipeline {
    agent any
    
    environment {
        // Variables d'environnement Ansible
        ANSIBLE_HOST_KEY_CHECKING = 'False'
        ANSIBLE_FORKS = '2'  // Optimis√© pour Raspberry Pi
        ANSIBLE_CONFIG = '/tmp/ansibleJenkins/ansible/ansible.cfg'
        // Variables sp√©cifiques pour le template post
        DEPLOYMENT_TYPE = 'DOCKER_COMPOSE'
        OPERATION_TYPE = 'MANAGE'
    }
    
    parameters {
        choice(
            name: 'TARGET_SERVER',
            choices: [
                'Windows',
                'ServerVM1', 
                'RaspberryPi2',
                'ReverseProxy',
                'Linux'
            ],
            description: 'Serveur cible pour le d√©ploiement'
        )
        text(
            name: 'DOCKER_RUN_COMMAND',
            defaultValue: '',
            description: '''üê≥ Commande Docker Run √† convertir en Docker Compose:
            
            EXEMPLE WINDOWS:
            docker run -p 3001:3001 --name anythingllm -ti --rm -v G:\\docker\\docker-data\\anything-llm:/app/data mintplexlabs/anythingllm:latest

            EXEMPLE LINUX:
            docker run -d -it --restart=unless-stopped -v $(pwd)/myelectricaldata/data:/data -p 5000:5000 -e TZ='Europe/Paris' m4dm4rtig4n/myelectricaldata:latest

            ‚úÖ Cette commande sera automatiquement convertie en docker-compose.yml'''
        )
        string(
            name: 'DOCKER_IMAGE_NAME',
            defaultValue: '',
            description: 'üè∑Ô∏è Nom du container/service (ex: keycloak, nginx, mysql, redis)'
        )
        string(
            name: 'DOCKER_COMPOSE_PATH',
            defaultValue: '',
            description: '''üìÅ Chemin o√π cr√©er le fichier docker-compose.yml:
            
            EXEMPLES WINDOWS:
            C:/docker-compose
            D:/projects/keycloak
            C:/temp/compose
            
            EXEMPLES LINUX:
            /opt/docker-compose
            /home/user/projects/webapp
            /tmp/compose
            
            ‚ö†Ô∏è Laisser vide pour utiliser le chemin par d√©faut selon l'OS'''
        )
        choice(
            name: 'ANSIBLE_VERBOSITY',
            choices: [
                '0',
                '1',
                '2',
                '3',
                '4'
            ],
            description: '''üîß Niveau de verbosit√© Ansible:
            
            0 = Normal (d√©faut)
            1 = Verbose (-v)
            2 = Plus verbose (-vv)
            3 = Debug (-vvv)
            4 = Debug complet (-vvvv)'''
        )
    }
    
    stages {
        stage('Validation des param√®tres') {
            steps {
                script {
                    echo "üîç Validation des param√®tres Docker Compose..."
                    echo "Serveur cible: ${params.TARGET_SERVER}"
                    echo "Verbosit√© Ansible: ${params.ANSIBLE_VERBOSITY}"
                    
                    // D√©terminer le flag de verbosit√©
                    def verbosityFlag = ''
                    if (params.ANSIBLE_VERBOSITY != '0') {
                        verbosityFlag = '-' + 'v' * params.ANSIBLE_VERBOSITY.toInteger()
                    }
                    env.ANSIBLE_VERBOSE_FLAG = verbosityFlag
                    echo "Flag de verbosit√©: '${env.ANSIBLE_VERBOSE_FLAG}'"
                    
                    // D√©terminer le type de serveur
                    def isWindows = params.TARGET_SERVER.toLowerCase().contains('windows')
                    def serverType = isWindows ? 'Windows' : 'Linux'
                    echo "Type de serveur d√©tect√©: ${serverType}"
                    env.SERVER_TYPE = serverType
                    
                    // D√©terminer le playbook selon le type de serveur
                    def selectedPlaybook = isWindows ? 'deploy_docker_container_windows.yml' : 'deploy_docker_container_linux.yml'
                    env.SELECTED_PLAYBOOK = selectedPlaybook
                    echo "Playbook s√©lectionn√©: ${env.SELECTED_PLAYBOOK}"
                    
                    // Validation des param√®tres obligatoires
                    if (params.DOCKER_RUN_COMMAND.trim() == '') {
                        error("La commande Docker Run est obligatoire")
                    }
                    if (params.DOCKER_IMAGE_NAME.trim() == '') {
                        error("Le nom du container/service est obligatoire")
                    }
                    
                    echo "‚úÖ Param√®tres Docker valid√©s:"
                    echo "   Container/Service: ${params.DOCKER_IMAGE_NAME}"
                    echo "   Commande: ${params.DOCKER_RUN_COMMAND}"
                    
                    // D√©terminer le chemin de composition selon l'OS
                    def defaultComposePath = isWindows ? 'C:/docker-compose' : '/opt/docker-compose'
                    def composePath = params.DOCKER_COMPOSE_PATH.trim() ?: defaultComposePath
                    
                    // Normaliser le chemin pour Ansible (toujours avec /)
                    def normalizedPath = composePath.replaceAll('\\\\', '/')
                    env.DOCKER_COMPOSE_PATH = normalizedPath
                    
                    echo "   Chemin Docker Compose: ${env.DOCKER_COMPOSE_PATH}"
                    
                    // Stocker les variables pour le post
                    env.DOCKER_IMAGE_DEPLOYED = params.DOCKER_IMAGE_NAME
                    env.DOCKER_COMMAND_USED = params.DOCKER_RUN_COMMAND
                }
            }
        }
        
        stage('V√©rification Ansible') {
            steps {
                script {
                    // V√©rifier qu'Ansible est install√©
                    sh 'ansible --version'
                    
                    // V√©rifier que le playbook existe
                    sh """
                        if [ ! -f "/tmp/ansibleJenkins/ansible/playbook/${env.SELECTED_PLAYBOOK}" ]; then
                            echo "‚ùå Playbook ${env.SELECTED_PLAYBOOK} non trouv√©!"
                            echo "Contenu du r√©pertoire playbook:"
                            ls -la /tmp/ansibleJenkins/ansible/playbook/ || echo "R√©pertoire non trouv√©"
                            exit 1
                        fi
                        
                        echo "‚úÖ Playbook ${env.SELECTED_PLAYBOOK} trouv√©"
                    """
                    
                    // V√©rifier la syntaxe du playbook
                    sh "ansible-playbook --syntax-check -i /tmp/ansibleJenkins/ansible/inventory/hosts.ini /tmp/ansibleJenkins/ansible/playbook/${SELECTED_PLAYBOOK} -e HOST=${TARGET_SERVER}"
                }
            }
        }
        
        stage('Pr√©paration des variables Ansible') {
            steps {
                script {
                    echo "üîß Pr√©paration des variables Ansible pour Docker Compose..."
                    
                    // Construire la structure docker_images
                    def dockerImagesJson = """
                    [{
                        "name": "${params.DOCKER_IMAGE_NAME}",
                        "container_name": "${params.DOCKER_IMAGE_NAME}",
                        "docker_run_var": "${params.DOCKER_RUN_COMMAND}",
                        "ports": "",
                        "volumes": "",
                        "restart_policy": "unless-stopped"
                    }]
                    """
                    
                    // Nettoyer le JSON (enlever les retours √† la ligne)
                    def cleanDockerImages = dockerImagesJson.replaceAll('\n', '').replaceAll('\\s+', ' ').trim()
                    
                    // Variables Ansible principales
                    def ansibleVars = []
                    ansibleVars << "docker_images='${cleanDockerImages}'"
                    ansibleVars << "docker_compose_path='${env.DOCKER_COMPOSE_PATH}'"
                    
                    // Stocker toutes les variables format√©es
                    env.ANSIBLE_EXTRA_VARS = ansibleVars.join(' ')
                    
                    echo "‚úÖ Variables Ansible pr√©par√©es:"
                    echo "   docker_images: Structure JSON avec ${params.DOCKER_IMAGE_NAME}"
                    echo "   docker_compose_path: ${env.DOCKER_COMPOSE_PATH}"
                    echo "Variables compl√®tes: ${env.ANSIBLE_EXTRA_VARS}"
                }
            }
        }
        
        stage('Ex√©cution du Playbook Docker Compose') {
            steps {
                script {
                    def isLinux = env.SELECTED_PLAYBOOK.contains('_linux.yml')
                    def isWindows = env.SELECTED_PLAYBOOK.contains('_windows.yml')

                    if (isLinux) {
                        withCredentials([
                            sshUserPrivateKey(credentialsId: 'ssh-key-ansible-user-secret-file', keyFileVariable: 'SSH_KEY_FILE', usernameVariable: 'SSH_USER')
                        ]) {
                        echo "üê≥ D√©marrage de la gestion Docker Compose..."
                        echo "Serveur: ${params.TARGET_SERVER} (${env.SERVER_TYPE})"
                        echo "Service: ${params.DOCKER_IMAGE_NAME}"
                        echo "Chemin: ${env.DOCKER_COMPOSE_PATH}"
                        echo "Playbook: ${env.SELECTED_PLAYBOOK}"
                        echo "Verbosit√©: ${params.ANSIBLE_VERBOSITY} ${env.ANSIBLE_VERBOSE_FLAG}"
                        
                        sh '''
                            echo "Ex√©cution du playbook Docker Compose..."
                            echo "Variables utilis√©es: ${ANSIBLE_EXTRA_VARS}"
                            echo "Flag de verbosit√©: ${ANSIBLE_VERBOSE_FLAG}"
                            
                            # Commande Ansible pour gestion Docker Compose
                            ansible-playbook -i /tmp/ansibleJenkins/ansible/inventory/hosts.ini \
                                /tmp/ansibleJenkins/ansible/playbook/${SELECTED_PLAYBOOK} \
                                -e HOST=${TARGET_SERVER} \
                                -e  ansible_ssh_private_key_file="${SSH_KEY_FILE}" \
                                -e "${ANSIBLE_EXTRA_VARS}" \
                                ${ANSIBLE_VERBOSE_FLAG}
                        '''
                        }
                    }
                    if (isWindows) {
                    withCredentials([
                        usernamePassword(credentialsId: 'credentials-id-windows-user-password', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')
                        ]) {
                        echo "üê≥ D√©marrage de la gestion Docker Compose..."
                        echo "Serveur: ${params.TARGET_SERVER} (${env.SERVER_TYPE})"
                        echo "Service: ${params.DOCKER_IMAGE_NAME}"
                        echo "Chemin: ${env.DOCKER_COMPOSE_PATH}"
                        echo "Playbook: ${env.SELECTED_PLAYBOOK}"
                        echo "Verbosit√©: ${params.ANSIBLE_VERBOSITY} ${env.ANSIBLE_VERBOSE_FLAG}"
                        
                        sh '''
                            echo "Ex√©cution du playbook Docker Compose..."
                            echo "Variables utilis√©es: ${ANSIBLE_EXTRA_VARS}"
                            echo "Flag de verbosit√©: ${ANSIBLE_VERBOSE_FLAG}"
                            
                            # Commande Ansible pour gestion Docker Compose
                            ansible-playbook -i /tmp/ansibleJenkins/ansible/inventory/hosts.ini \
                                /tmp/ansibleJenkins/ansible/playbook/${SELECTED_PLAYBOOK} \
                                -e HOST=${TARGET_SERVER} \
                                -e ansible_user="${USERNAME}" \
                                -e ansible_password="${PASSWORD}" \
                                -e "${ANSIBLE_EXTRA_VARS}" \
                                ${ANSIBLE_VERBOSE_FLAG}
                        '''
                       }
                    }
                }
            }
        }
    }
    
post {
    always {
        echo "Gestion Docker Compose termin√©e"
        
        // Cr√©er un rapport d√©taill√©
        script {
            def report = """
            === RAPPORT DOCKER COMPOSE DEPLOYMENT ===
            Service: ${params.DOCKER_IMAGE_NAME}
            Commande Docker: ${params.DOCKER_RUN_COMMAND ?: 'Non sp√©cifi√©e'}
            Serveur Cible: ${params.TARGET_SERVER}
            Type Serveur: ${env.SERVER_TYPE ?: 'Non d√©fini'}
            Chemin Compose: ${env.DOCKER_COMPOSE_PATH ?: 'Non d√©fini'}
            Playbook: ${env.SELECTED_PLAYBOOK ?: 'Non d√©fini'}
            Variables Ansible: ${env.ANSIBLE_EXTRA_VARS ?: 'Non g√©n√©r√©es'}
            Build: #${env.BUILD_NUMBER}
            Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}
            Statut: ${currentBuild.currentResult}
            Dur√©e: ${currentBuild.durationString ?: 'N/A'}
            ==========================================
            """
            writeFile file: 'docker_compose_deployment_report.txt', text: report
            archiveArtifacts artifacts: 'docker_compose_deployment_report.txt', allowEmptyArchive: true
        }
    }
    success {
        script {
            echo "Service Docker Compose '${params.DOCKER_IMAGE_NAME}' d√©ploy√© avec succ√®s!"
            
            currentBuild.description = "Docker Compose ${params.DOCKER_IMAGE_NAME} ‚Üí ${params.TARGET_SERVER}"
            
            // Cr√©er le corps de l'email en texte avec formatage
            def emailBody = """
                üê≥ DOCKER COMPOSE DEPLOYMENT - SUCC√àS

                Service: ${params.DOCKER_IMAGE_NAME}
                Commande: ${params.DOCKER_RUN_COMMAND ?: 'Non sp√©cifi√©e'}
                Serveur: ${params.TARGET_SERVER}
                Type Serveur: ${env.SERVER_TYPE ?: 'Non d√©fini'}
                Chemin Compose: ${env.DOCKER_COMPOSE_PATH ?: 'Non d√©fini'}
                Build: #${env.BUILD_NUMBER}
                Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}
                Dur√©e: ${currentBuild.durationString ?: 'N/A'}

                üìä D√©tails du build: ${env.BUILD_URL}

                Configuration utilis√©e:
                - Playbook: ${env.SELECTED_PLAYBOOK ?: 'Non d√©fini'}
                - Variables Ansible: ${env.ANSIBLE_EXTRA_VARS ? 'G√©n√©r√©es' : 'Non g√©n√©r√©es'}

                ‚úÖ Le d√©ploiement Docker Compose s'est termin√© avec succ√®s.
            """
            
            mail to: 'l.kieran95@gmail.com',
                subject: "[Jenkins] Docker Compose - ${params.DOCKER_IMAGE_NAME} - Succ√®s",
                body: emailBody
        }
    }
    failure {
        script {
            echo "√âchec du d√©ploiement Docker Compose '${params.DOCKER_IMAGE_NAME}'"
            
            currentBuild.description = "Docker Compose ${params.DOCKER_IMAGE_NAME} ‚Üí √âCHEC"
            
            // Cr√©er le corps de l'email d'√©chec
            def emailBody = """
                ‚ùå DOCKER COMPOSE DEPLOYMENT - √âCHEC

                Service: ${params.DOCKER_IMAGE_NAME}
                Commande: ${params.DOCKER_RUN_COMMAND ?: 'Non sp√©cifi√©e'}
                Serveur: ${params.TARGET_SERVER}
                Type Serveur: ${env.SERVER_TYPE ?: 'Non d√©fini'}
                Chemin Compose: ${env.DOCKER_COMPOSE_PATH ?: 'Non d√©fini'}
                Build: #${env.BUILD_NUMBER}
                Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}

                üîç Logs d'erreur: ${env.BUILD_URL}console

                Configuration utilis√©e:
                - Playbook: ${env.SELECTED_PLAYBOOK ?: 'Non d√©fini'}

                Variables Ansible g√©n√©r√©es:
                ${env.ANSIBLE_EXTRA_VARS ?: 'Non g√©n√©r√©es'}

                ‚ö†Ô∏è Veuillez v√©rifier les logs pour plus de d√©tails.
            """
            
            mail to: 'l.kieran95@gmail.com',
                subject: "[Jenkins] Docker Compose - √âchec - ${params.DOCKER_IMAGE_NAME}",
                body: emailBody
        }
    }
    cleanup {
        cleanWs()
    }
}
}