pipeline {
    agent any
    
    environment {
        ANSIBLE_HOST_KEY_CHECKING = 'False'
        ANSIBLE_FORKS = '2'
        ANSIBLE_CONFIG = '/tmp/ansibleJenkins/ansible/ansible.cfg'
    }
    
    parameters {
        choice(
            name: 'TARGET_SERVER',
            choices: [
                'ReverseProxy',
                'Linux',
                'ServerVM1', 
                'RaspberryPi2',
                'all-linux',
                'debian-servers',
                'redhat-servers'
            ],
            description: 'Serveur cible pour le rapport de sécurité'
        )
        choice(
            name: 'ANSIBLE_VERBOSITY',
            choices: [
                '0',
                '1',
                '2',
                '3',
                '4'
            ],
            description: '''Niveau de verbosité Ansible:
            
            0 = Normal (défaut)
            1 = Verbose (-v)
            2 = Plus verbose (-vv)
            3 = Debug (-vvv)
            4 = Debug complet (-vvvv)'''
        )
        text(
            name: 'EXTRA_VARS',
            defaultValue: '',
            description: 'Variables Ansible supplémentaires (format: key=value séparées par espaces)'
        )
    }
    
    stages {
        stage('Validation des paramètres') {
            steps {
                script {
                    echo "Validation des paramètres Security Report..."
                    echo "Serveur cible: ${params.TARGET_SERVER}"
                    echo "Verbosité Ansible: ${params.ANSIBLE_VERBOSITY}"
                    
                    // Déterminer le flag de verbosité
                    def verbosityFlag = ''
                    if (params.ANSIBLE_VERBOSITY != '0') {
                        verbosityFlag = '-' + 'v' * params.ANSIBLE_VERBOSITY.toInteger()
                    }
                    env.ANSIBLE_VERBOSE_FLAG = verbosityFlag
                    echo "Flag de verbosité: '${env.ANSIBLE_VERBOSE_FLAG}'"
                    
                    // Configuration des variables d'environnement
                    env.OPERATION_TYPE = 'SECURITY_SCAN'
                    env.SELECTED_PLAYBOOK = 'security_scan.yml'
                }
            }
        }
        
        stage('Vérification Ansible') {
            steps {
                script {
                    // Vérifier qu'Ansible est installé
                    sh 'ansible --version'
                    
                    // Vérifier que le playbook existe
                    sh """
                        if [ ! -f "/tmp/ansibleJenkins/ansible/playbook/${env.SELECTED_PLAYBOOK}" ]; then
                            echo "Playbook ${env.SELECTED_PLAYBOOK} non trouvé!"
                            echo "Contenu du répertoire playbook:"
                            ls -la /tmp/ansibleJenkins/ansible/playbook/ || echo "Répertoire non trouvé"
                            exit 1
                        fi
                        
                        echo "Playbook ${env.SELECTED_PLAYBOOK} trouvé"
                    """
                    
                    // Vérifier la syntaxe du playbook
                    sh "ansible-playbook --syntax-check -i /tmp/ansibleJenkins/ansible/inventory/hosts.ini /tmp/ansibleJenkins/ansible/playbook/${SELECTED_PLAYBOOK} -e HOST=${TARGET_SERVER}"
                }
            }
        }
        
        stage('Préparation des variables Ansible') {
            steps {
                script {
                    echo "Préparation des variables Ansible pour Security Report..."
                    
                    // Variables Ansible principales
                    def ansibleVars = []
                    ansibleVars << "HOST='${params.TARGET_SERVER}'"
                    ansibleVars << "report_dir='${env.WORKSPACE}/security_reports'" 

                    
                    // Variables supplémentaires
                    if (params.EXTRA_VARS.trim() != '') {
                        ansibleVars << params.EXTRA_VARS.trim()
                    }
                    
                    // Stocker toutes les variables formatées
                    env.ANSIBLE_EXTRA_VARS = ansibleVars.join(' ')
                    
                    echo "Variables Ansible préparées:"
                    echo "Variables complètes: ${env.ANSIBLE_EXTRA_VARS}"
                }
            }
        }
        
        stage('Scan de sécurité') {
            steps {
                script {
                   withCredentials([sshUserPrivateKey(credentialsId: 'ssh-key-ansible-user-secret-file', keyFileVariable: 'SSH_KEY_FILE', usernameVariable: 'SSH_USER')]) { 
                        sh '''
                            ansible-playbook -i /tmp/ansibleJenkins/ansible/inventory/hosts.ini \
                                -e ansible_ssh_private_key_file="${SSH_KEY_FILE}" \
                                /tmp/ansibleJenkins/ansible/playbook/${SELECTED_PLAYBOOK} \
                                -e "${ANSIBLE_EXTRA_VARS}" \
                                ${ANSIBLE_VERBOSE_FLAG}
                        '''
                    }
                }
            }
        }
    }
    
    post {
        always {
            echo "Scan de sécurité terminé"
            
            // Archiver les rapports générés
            script {
                sh '''
                    # Archiver les rapports de sécurité s'ils existent
                    if [ -d "./security_reports" ]; then
                        find ./security_reports -name "*.html" -o -name "*.json" | head -20
                    fi
                '''
                
                // Archiver les rapports
                archiveArtifacts artifacts: 'security_reports/**/*', allowEmptyArchive: true
                
                def report = """
                === RAPPORT SECURITY SCAN ===
                Type de scan: ${params.SCAN_TYPE}
                Serveur cible: ${params.TARGET_SERVER}
                Verbosité Ansible: ${params.ANSIBLE_VERBOSITY}
                Variables extra: ${params.EXTRA_VARS ?: 'Aucune'}
                Variables Ansible: ${env.ANSIBLE_EXTRA_VARS ?: 'Non générées'}
                Playbook: ${env.SELECTED_PLAYBOOK ?: 'Non défini'}
                Build: #${env.BUILD_NUMBER}
                Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}
                Statut: ${currentBuild.currentResult}
                Durée: ${currentBuild.durationString ?: 'N/A'}
                ====================================
                """
                writeFile file: 'security_scan_report.txt', text: report
                archiveArtifacts artifacts: 'security_scan_report.txt', allowEmptyArchive: true
            }
        }
        success {
            script {
                echo "Scan de sécurité réussi! Type '${params.SCAN_TYPE}' sur ${params.TARGET_SERVER}"
                
                currentBuild.description = "Security ${params.SCAN_TYPE} → ${params.TARGET_SERVER}"
                
                // Créer le corps de l'email de succès
                def emailBody = """
                    SECURITY SCAN - SUCCÈS

                    Type de scan: ${params.SCAN_TYPE}
                    Serveur cible: ${params.TARGET_SERVER}
                    Verbosité Ansible: ${params.ANSIBLE_VERBOSITY}
                    Build: #${env.BUILD_NUMBER}
                    Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}
                    Durée: ${currentBuild.durationString ?: 'N/A'}

                    Détails du build: ${env.BUILD_URL}
                    Rapports: ${env.BUILD_URL}artifact/

                    Configuration utilisée:
                    - Playbook: ${env.SELECTED_PLAYBOOK ?: 'Non défini'}
                    - Variables Ansible: ${env.ANSIBLE_EXTRA_VARS ? 'Générées' : 'Non générées'}

                    Le scan de sécurité '${params.SCAN_TYPE}' a été exécuté avec succès.
                    
                    Les rapports de sécurité sont disponibles dans les artifacts du build.
                """
                
                mail to: 'l.kieran95@gmail.com',
                    subject: "[Jenkins] Security Scan - ${params.SCAN_TYPE} sur ${params.TARGET_SERVER} - Succès",
                    body: emailBody
            }
        }
        failure {
            script {
                echo "Échec du scan de sécurité - Type '${params.SCAN_TYPE}' sur ${params.TARGET_SERVER}"
                
                currentBuild.description = "Security ${params.SCAN_TYPE} → ÉCHEC"
                
                // Créer le corps de l'email d'échec
                def emailBody = """
                    SECURITY SCAN - ÉCHEC

                    Type de scan: ${params.SCAN_TYPE}
                    Serveur cible: ${params.TARGET_SERVER}
                    Verbosité Ansible: ${params.ANSIBLE_VERBOSITY}
                    Build: #${env.BUILD_NUMBER}
                    Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}

                    Logs d'erreur: ${env.BUILD_URL}console

                    Configuration utilisée:
                    - Playbook: ${env.SELECTED_PLAYBOOK ?: 'Non défini'}
                    - Variables extra: ${params.EXTRA_VARS ?: 'Aucune'}

                    Variables Ansible générées:
                    ${env.ANSIBLE_EXTRA_VARS ?: 'Non générées'}

                    Veuillez vérifier les logs pour plus de détails.
                """
                
                mail to: 'l.kieran95@gmail.com',
                    subject: "[Jenkins] Security Scan - Échec - ${params.SCAN_TYPE} sur ${params.TARGET_SERVER}",
                    body: emailBody
            }
        }
        cleanup {
            cleanWs()
        }
    }
}