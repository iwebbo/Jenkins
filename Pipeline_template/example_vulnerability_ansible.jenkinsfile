pipeline {
    agent { label 'devops-agent' }
    options {
        ansiColor('xterm')
    }

    environment {
        ANSIBLE_FORCE_COLOR = 'true'
        ANSIBLE_STDOUT_CALLBACK = 'yaml'
        ANSIBLE_HOST_KEY_CHECKING = 'False'
        ANSIBLE_FORKS = '2'
        ANSIBLE_CONFIG = "${WORKSPACE}/ansible.cfg"
        ANSIBLE_INVENTORY = "${WORKSPACE}/inventory/hosts.ini"
        PLAYBOOK_PATH = "${WORKSPACE}/playbook/security_scan.yml"
        EMAIL_RECIPIENT = 'email@email.com'
    }
    
    parameters {
        choice(
            name: 'TARGET_SERVER',
            choices: [
                'all',
                'Linux',
                'Windows'
            ],
            description: 'Serveur cible pour le rapport de sécurité'
        )
        booleanParam(
            name: 'DRY_RUN',
            defaultValue: false,
            description: 'Activer le mode dry-run (--check) pour simuler les changements sans les appliquer'
        )
        choice(
            name: 'ANSIBLE_VERBOSITY',
            choices: [
                '0',
                '1',
                '2',
                '3',
                '4'
            ],
            description: '''Niveau de verbosité Ansible:
            
            0 = Normal (défaut)
            1 = Verbose (-v)
            2 = Plus verbose (-vv)
            3 = Debug (-vvv)
            4 = Debug complet (-vvvv)'''
        )
        text(
            name: 'EXTRA_VARS',
            defaultValue: '',
            description: 'Variables Ansible supplémentaires (format: key=value séparées par espaces)'
        )
    }
    
    stages {

        stage('Checkout SCM') {
            steps {
                script {
                    checkout scm
                    sh '''
                        echo "Workspace cloned"
                    '''
                }
            }
        }

        stage('Parameters Verification') {
            steps {
                script {
                    echo "=== Parameters Validation ==="
                    echo "Target server: ${params.TARGET_SERVER}"
                    echo "Verbosity: ${params.ANSIBLE_VERBOSITY}"
                    
                    // Determine verbosity flag
                    def verbosityFlag = ''
                    if (params.ANSIBLE_VERBOSITY != '0') {
                        verbosityFlag = '-' + 'v' * params.ANSIBLE_VERBOSITY.toInteger()
                    }
                    env.ANSIBLE_VERBOSE_FLAG = verbosityFlag
                    echo "Verbosity flag: '${env.ANSIBLE_VERBOSE_FLAG ?: 'None'}'"

                    def ansibleFlags = []
                    if (params.DRY_RUN) {
                        ansibleFlags << '--check'
                    }
                    env.ANSIBLE_CHECK_FLAGS = ansibleFlags.join(' ')
                    echo "Dry-run flags: '${env.ANSIBLE_CHECK_FLAGS ?: 'None (mode réel)'}'"

                    // Check Ansible
                    sh 'ansible --version'
                }
            }
        }
        
        stage('Préparation des variables Ansible') {
            steps {
                script {
                    echo "Préparation des variables Ansible pour Security Report..."
                    
                    // Variables Ansible principales
                    def ansibleVars = []
                    ansibleVars << "HOST='${params.TARGET_SERVER}'"
                    ansibleVars << "report_dir='${env.WORKSPACE}/security_reports'" 

                    
                    // Variables supplémentaires
                    if (params.EXTRA_VARS.trim() != '') {
                        ansibleVars << params.EXTRA_VARS.trim()
                    }
                    
                    // Stocker toutes les variables formatées
                    env.ANSIBLE_EXTRA_VARS = ansibleVars.join(' ')
                    
                    echo "Variables Ansible préparées:"
                    echo "Variables complètes: ${env.ANSIBLE_EXTRA_VARS}"
                }
            }
        }
        
        stage('Scan de sécurité') {
            steps {
                script {
                   withCredentials([sshUserPrivateKey(credentialsId: 'ssh-key-ansible-user-secret-file', keyFileVariable: 'SSH_KEY_FILE', usernameVariable: 'SSH_USER')]) { 
                        sh """
                            ansible-playbook \
                                -i ${ANSIBLE_INVENTORY} \
                                -e ansible_ssh_private_key_file="\${SSH_KEY_FILE}" \
                                -e "${ANSIBLE_EXTRA_VARS}" \
                                ${PLAYBOOK_PATH} \
                                ${ANSIBLE_CHECK_FLAGS} \
                                ${ANSIBLE_VERBOSE_FLAG}
                        """
                    }
                }
            }
        }
    }
    
    post {
        always {
            echo "Scan de sécurité terminé"
            
            // Archiver les rapports générés
            script {
                sh '''
                    # Archiver les rapports de sécurité s'ils existent
                    if [ -d "./security_reports" ]; then
                        find ./security_reports -name "*.html" -o -name "*.json" | head -20
                    fi
                '''
                
                // Archiver les rapports
                archiveArtifacts artifacts: 'security_reports/**/*', allowEmptyArchive: true
                
                def report = """
                === RAPPORT SECURITY SCAN ===
                Type de scan: ${params.SCAN_TYPE}
                Serveur cible: ${params.TARGET_SERVER}
                Verbosité Ansible: ${params.ANSIBLE_VERBOSITY}
                Variables extra: ${params.EXTRA_VARS ?: 'Aucune'}
                Variables Ansible: ${env.ANSIBLE_EXTRA_VARS ?: 'Non générées'}
                Playbook: ${env.SELECTED_PLAYBOOK ?: 'Non défini'}
                Build: #${env.BUILD_NUMBER}
                Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}
                Statut: ${currentBuild.currentResult}
                Durée: ${currentBuild.durationString ?: 'N/A'}
                ====================================
                """
                writeFile file: 'security_scan_report.txt', text: report
                archiveArtifacts artifacts: 'security_scan_report.txt', allowEmptyArchive: true
            }
        }
        success {
            script {                
                currentBuild.description = "Security Scan on → ${params.TARGET_SERVER}"
                
                // Créer le corps de l'email de succès
                def emailBody = """
                    SECURITY SCAN - SUCCÈS

                    Type de scan: ${params.SCAN_TYPE}
                    Serveur cible: ${params.TARGET_SERVER}
                    Verbosité Ansible: ${params.ANSIBLE_VERBOSITY}
                    Build: #${env.BUILD_NUMBER}
                    Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}
                    Durée: ${currentBuild.durationString ?: 'N/A'}

                    Détails du build: ${env.BUILD_URL}
                    Rapports: ${env.BUILD_URL}artifact/

                    Configuration utilisée:
                    - Playbook: ${env.SELECTED_PLAYBOOK ?: 'Non défini'}
                    - Variables Ansible: ${env.ANSIBLE_EXTRA_VARS ? 'Générées' : 'Non générées'}

                    Le scan de sécurité '${params.SCAN_TYPE}' a été exécuté avec succès.
                    
                    Les rapports de sécurité sont disponibles dans les artifacts du build.
                """
                
                 mail to: "${env.EMAIL_RECIPIENT}",
                    subject: "[Jenkins] Security Scan sur ${params.TARGET_SERVER} - Succès",
                    body: emailBody
            }
        }
        failure {
            script {
                currentBuild.description = "Security scan → ÉCHEC"
                
                // Créer le corps de l'email d'échec
                def emailBody = """
                    SECURITY SCAN - ÉCHEC

                    Type de scan: ${params.SCAN_TYPE}
                    Serveur cible: ${params.TARGET_SERVER}
                    Verbosité Ansible: ${params.ANSIBLE_VERBOSITY}
                    Build: #${env.BUILD_NUMBER}
                    Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}

                    Logs d'erreur: ${env.BUILD_URL}console

                    Configuration utilisée:
                    - Playbook: ${env.SELECTED_PLAYBOOK ?: 'Non défini'}
                    - Variables extra: ${params.EXTRA_VARS ?: 'Aucune'}

                    Variables Ansible générées:
                    ${env.ANSIBLE_EXTRA_VARS ?: 'Non générées'}

                    Veuillez vérifier les logs pour plus de détails.
                """
                
                 mail to: "${env.EMAIL_RECIPIENT}",
                    subject: "[Jenkins] Security Scan - Échec - ${params.SCAN_TYPE} sur ${params.TARGET_SERVER}",
                    body: emailBody
            }
        }
        cleanup {
            echo "Nettoyage du workspace..."
            cleanWs()
        }
    }
}